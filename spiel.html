<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MindMaze Pro — Enhanced (Single File)</title>
<style>
  :root{--bg:#071020;--panel:rgba(0,0,0,0.45);--accent:#7ef;--danger:#ff6b6b}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#02030a,#071020)}
  #wrap{width:100%;height:100%;display:flex;align-items:center;justify-content:center;padding:12px;box-sizing:border-box}
  #gameBox{width:min(1200px,98vw);height:min(780px,96vh);position:relative;border-radius:12px;overflow:hidden;box-shadow:0 12px 40px rgba(0,0,0,0.6)}
  canvas{display:block;width:100%;height:100%}
  .panel{background:var(--panel);padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);color:#eaf}
  #menu{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:40;background:linear-gradient(rgba(0,0,0,0.45),rgba(0,0,0,0.6))}
  #ui{position:absolute;left:14px;top:12px;color:#dff;z-index:50}
  #controls{position:absolute;right:14px;top:12px;color:#cfe;z-index:50;text-align:right;font-size:13px}
  #minimap{position:absolute;left:12px;bottom:12px;width:200px;height:200px;background:rgba(0,0,0,0.5);border-radius:8px;padding:8px;z-index:50}
  #editorTools{position:absolute;right:12px;bottom:12px;z-index:60}
  button.btn{cursor:pointer;border-radius:8px;padding:8px 12px;border:none;background:linear-gradient(90deg,var(--accent),#6bf);color:#012;font-weight:700}
  footer{position:absolute;right:12px;bottom:12px;color:rgba(200,220,255,0.6);z-index:30;font-size:12px}
  input[type=file]{display:none}
  h2{margin:0 0 8px}
  .muted{color:rgba(220,240,255,0.75)}
  @media (max-width:720px){
    #minimap{width:140px;height:140px}
  }
</style>
</head>
<body>
<div id="wrap">
  <div id="gameBox">
    <canvas id="view"></canvas>

    <div id="ui" class="panel">
      <div style="font-weight:700">MindMaze Pro</div>
      <div style="font-size:13px;margin-top:6px">Status: <span id="status">Ready</span></div>
      <div style="font-size:13px;margin-top:6px">Best: <span id="best">--</span>s</div>
    </div>

    <div id="controls" class="panel">
      <div style="font-size:13px">W/A/S/D · Pfeile bewegen · Maus drehen · Shift schleichen</div>
      <div style="font-size:13px;margin-top:6px">Linksklick = Stein werfen · E = Editor</div>
    </div>

    <div id="minimap" class="panel"></div>

    <div id="editorTools" style="display:none">
      <div class="panel">
        <div style="margin-bottom:6px;font-weight:700">Designer Mode</div>
        <div style="display:flex;gap:6px;margin-bottom:6px">
          <button id="toolWall" class="btn">Wand</button>
          <button id="toolFloor" class="btn">Boden</button>
          <button id="toolExit" class="btn">Exit</button>
        </div>
        <div style="display:flex;gap:6px">
          <button id="saveMap" class="btn">Speichern</button>
          <button id="exportMap" class="btn">Export (.json)</button>
          <button id="importMapBtn" class="btn">Import</button>
          <input id="importMap" type="file" accept="application/json" />
        </div>
        <div style="margin-top:8px;font-size:12px;color:rgba(220,240,255,0.7)">Ziehe WAV/OGG auf die Minimap, um Hintergrundmusik zu laden.</div>
      </div>
    </div>

    <div id="menu">
      <div class="panel" style="min-width:360px;text-align:center">
        <h2>MindMaze Pro</h2>
        <div class="muted">Enhanced lighting, textured walls, A* pathfinding, enemy types, sounds, editor.</div>
        <div style="display:flex;gap:8px;justify-content:center;margin-top:12px">
          <button id="startBtn" class="btn">Spiel starten</button>
          <button id="editorBtn" class="btn">Designer öffnen</button>
        </div>
        <div style="margin-top:10px;font-size:13px">Tipp: E drücken, um Designer zu öffnen/schließen.</div>
      </div>
    </div>

    <footer class="panel">MindMaze Pro — für Lernende. Editor: E</footer>
  </div>
</div>

<script>
/* MindMaze Pro — Single-file enhanced version (ready to save) */

/* ===== CONFIG ===== */
const CONFIG = {
  CELL_SIZE: 64,
  MAP_W: 21,
  MAP_H: 21,
  FOV: Math.PI * 0.62,
  RENDER_DIST: 16,
  ENEMIES: 4,
  STEP_SOUND_INTERVAL: 0.22,
  SNEAK_MULT: 0.45,
  RUN_MULT: 1.0,
  WALK_MULT: 0.7
};

/* ===== DOM ===== */
const canvas = document.getElementById('view');
const ctx = canvas.getContext('2d');
const menu = document.getElementById('menu');
const startBtn = document.getElementById('startBtn');
const editorBtn = document.getElementById('editorBtn');
const statusEl = document.getElementById('status');
const bestEl = document.getElementById('best');
const minimapEl = document.getElementById('minimap');
const editorTools = document.getElementById('editorTools');
const importMapInput = document.getElementById('importMap');

let W = 1100, H = 700;
function resize(){ const r = canvas.getBoundingClientRect(); W = Math.round(r.width); H = Math.round(r.height); canvas.width = W; canvas.height = H; }
window.addEventListener('resize', resize);
resize();

/* ===== AUDIO ===== */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const actx = new AudioCtx();
let audioBuffers = { step:null, stone:null, alert:null, bg:null };
let bgSource = null;

function synthBeep(freq=440, t=0.08, type='sine', vol=0.06){
  const o = actx.createOscillator(); const g = actx.createGain();
  o.type = type; o.frequency.value = freq; g.gain.value = vol;
  o.connect(g); g.connect(actx.destination);
  o.start();
  g.gain.exponentialRampToValueAtTime(0.0001, actx.currentTime + t);
  setTimeout(()=>{ try{o.stop()}catch(e){} }, (t+0.05)*1000);
}
function playBuffer(buf, vol=0.8, loop=false){
  if(!buf) return null;
  const s = actx.createBufferSource(); s.buffer = buf;
  const g = actx.createGain(); g.gain.value = vol;
  s.connect(g); g.connect(actx.destination);
  s.loop = loop;
  s.start();
  return s;
}

/* Load user audio via file input */
importMapInput.addEventListener('change', e=>{
  const f = e.target.files[0]; if(!f) return;
  const reader = new FileReader();
  reader.onload = ev=>{
    try{
      const obj = JSON.parse(ev.target.result);
      loadMapFromObject(obj);
      msg('Map importiert');
    } catch(err){ msg('Ungültiges JSON'); }
  };
  reader.readAsText(f);
});

/* Drag Drop audio onto minimap */
minimapEl.addEventListener('dragover', e=>{ e.preventDefault(); minimapEl.style.outline = '2px dashed rgba(255,255,255,0.12)'; });
minimapEl.addEventListener('dragleave', e=>{ minimapEl.style.outline = 'none'; });
minimapEl.addEventListener('drop', e=>{
  e.preventDefault(); minimapEl.style.outline = 'none';
  const f = e.dataTransfer.files[0]; if(!f) return;
  if(!f.type.startsWith('audio')) return msg('Nur Audio-Dateien');
  const fr = new FileReader();
  fr.onload = ev=>{
    actx.decodeAudioData(ev.target.result).then(buf=>{
      audioBuffers.bg = buf; msg('Hintergrund-Audio geladen');
      if(bgSource) try{ bgSource.stop(); }catch(e){}
      bgSource = playBuffer(audioBuffers.bg, 0.35, true);
    }).catch(()=> msg('Audio konnte nicht decodiert werden'));
  };
  fr.readAsArrayBuffer(f);
});

/* ===== UTIL ===== */
function rand(min,max){return Math.random()*(max-min)+min}
function clamp(a,b,c){return Math.max(b,Math.min(c,a))}

/* ===== MAP / MAZE and Editor ===== */
function makeEmptyMap(w,h){ const map=[]; for(let y=0;y<h;y++){ map[y]=[]; for(let x=0;x<w;x++) map[y][x]=0; } return map; }

function generateMaze(cols, rows){
  if(cols%2===0) cols++;
  if(rows%2===0) rows++;
  const map = makeEmptyMap(cols,rows);
  for(let y=1;y<rows;y+=2) for(let x=1;x<cols;x+=2) map[y][x]=1;
  const visited = {}; function key(x,y){return x+','+y;}
  const stack = [[1,1]]; visited[key(1,1)] = true;
  while(stack.length){
    const [cx,cy] = stack[stack.length-1];
    const neighbors = [];
    const deltas = [[2,0],[-2,0],[0,2],[0,-2]];
    for(const d of deltas){
      const nx = cx + d[0], ny = cy + d[1];
      if(nx>0 && nx<cols && ny>0 && ny<rows && !visited[key(nx,ny)]) neighbors.push([nx,ny]);
    }
    if(neighbors.length){
      const n = neighbors[Math.floor(Math.random()*neighbors.length)];
      const wx = (cx + n[0]) / 2, wy = (cy + n[1]) / 2;
      map[wy][wx] = 1;
      visited[key(n[0],n[1])] = true;
      stack.push(n);
    } else stack.pop();
  }
  const exit = {x: cols-2, y: rows-2};
  map[exit.y][exit.x] = 1;
  return {map, cols, rows, exit};
}

let world = null;
function initWorld(){
  world = generateMaze(CONFIG.MAP_W, CONFIG.MAP_H);
  world.exitPos = { x: world.exit.x + 0.5, y: world.exit.y + 0.5 };
}

/* Editor state */
let editor = { active:false, tool:'wall' };
function openEditor(){ editor.active=true; editorTools.style.display='block'; menu.style.display='none'; setupEditor(); drawMinimap(); }
function closeEditor(){ editor.active=false; editorTools.style.display='none'; menu.style.display='flex'; }

function setupEditor(){
  document.getElementById('toolWall').onclick = ()=>{ editor.tool='wall'; msg('Tool: Wand'); };
  document.getElementById('toolFloor').onclick = ()=>{ editor.tool='floor'; msg('Tool: Boden'); };
  document.getElementById('toolExit').onclick = ()=>{ editor.tool='exit'; msg('Tool: Exit'); };
  document.getElementById('saveMap').onclick = ()=>{ localStorage.setItem('mindmaze_map', JSON.stringify(world)); msg('Map gespeichert'); };
  document.getElementById('exportMap').onclick = ()=>{ const data = JSON.stringify(world); const blob = new Blob([data], {type:'application/json'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'mindmaze_map.json'; a.click(); URL.revokeObjectURL(url); };
  document.getElementById('importMapBtn').onclick = ()=>{ importMapInput.click(); };
}

/* apply tool at minimap cell */
function applyTool(cellX, cellY){
  if(cellX < 0 || cellY < 0 || cellY >= world.rows || cellX >= world.cols) return;
  if(editor.tool === 'wall') world.map[cellY][cellX] = 0;
  else if(editor.tool === 'floor') world.map[cellY][cellX] = 1;
  else if(editor.tool === 'exit'){ world.exit.x = cellX; world.exit.y = cellY; world.exitPos = {x:cellX+0.5,y:cellY+0.5}; }
  drawMinimap();
}

/* click handling on minimap for editor */
minimapEl.addEventListener('pointerdown', e=>{
  if(!editor.active) return;
  const rect = minimapEl.getBoundingClientRect();
  const tx = (e.clientX - rect.left) / rect.width;
  const ty = (e.clientY - rect.top) / rect.height;
  const cellX = Math.floor(tx * world.cols);
  const cellY = Math.floor(ty * world.rows);
  applyTool(cellX, cellY);
});

/* load map object into world */
function loadMapFromObject(obj){
  if(!obj || !obj.map) return;
  world = obj;
  world.cols = world.map[0].length;
  world.rows = world.map.length;
  world.exitPos = { x: world.exit.x + 0.5, y: world.exit.y + 0.5 };
  drawMinimap();
}

/* check saved map */
const saved = localStorage.getItem('mindmaze_map');
if(saved){
  try{ const obj = JSON.parse(saved); loadMapFromObject(obj); msg('Gespeicherte Map geladen'); } catch(e){}
}

/* ===== PLAYER ===== */
let player = null;
function initPlayer(){ player = { x:1.5, y:1.5, dir:0, speed:3.2, sneaking:false, noise:0 }; }

/* ===== A* PATHFINDING ===== */
class AStar {
  constructor(map){ this.map = map; this.w = map[0].length; this.h = map.length; }
  neighbors(node){
    const [x,y] = node; const out = [];
    const deltas = [[1,0],[-1,0],[0,1],[0,-1]];
    for(const d of deltas){
      const nx = x + d[0], ny = y + d[1];
      if(nx>=0 && ny>=0 && nx<this.w && ny<this.h && this.map[ny][nx] === 1) out.push([nx,ny]);
    }
    return out;
  }
  heuristic(a,b){ return Math.abs(a[0]-b[0]) + Math.abs(a[1]-b[1]); }
  findPath(sx,sy,tx,ty){
    const start = [Math.floor(sx), Math.floor(sy)];
    const target = [Math.floor(tx), Math.floor(ty)];
    const key = n => n[0]+','+n[1];
    const open = new Map(); const came = new Map(); const g = new Map(); const f = new Map();
    g.set(key(start), 0); f.set(key(start), this.heuristic(start, target)); open.set(key(start), start);
    while(open.size){
      let curKey=null, cur=null, best=Infinity;
      for(const [kk,node] of open){ const fv = f.get(kk) || Infinity; if(fv < best){ best = fv; curKey = kk; cur = node; } }
      if(!cur) break;
      open.delete(curKey);
      if(cur[0] === target[0] && cur[1] === target[1]){
        const path = []; let ck = curKey;
        while(came.has(ck)){ const parts = ck.split(',').map(Number); path.unshift(parts); ck = came.get(ck); }
        path.unshift(start); return path;
      }
      for(const nb of this.neighbors(cur)){
        const nk = key(nb);
        const tentative = (g.get(curKey) || Infinity) + 1;
        if(tentative < (g.get(nk) || Infinity)){
          came.set(nk, curKey);
          g.set(nk, tentative);
          f.set(nk, tentative + this.heuristic(nb, target));
          if(!open.has(nk)) open.set(nk, nb);
        }
      }
    }
    return null;
  }
}

/* ===== ENEMIES ===== */
let enemies = [];
function spawnEnemies(){
  enemies = [];
  const types = ['patrol','stationary','sprinter'];
  let placed = 0, tries = 0;
  while(placed < CONFIG.ENEMIES && tries < 1500){
    tries++;
    const rx = Math.floor(rand(1, world.cols-1));
    const ry = Math.floor(rand(1, world.rows-1));
    if(world.map[ry] && world.map[ry][rx] === 1){
      const d0 = Math.hypot(rx-1, ry-1);
      const de = Math.hypot(rx - world.exit.x, ry - world.exit.y);
      if(d0 > 4 && de > 4){
        const t = types[Math.floor(Math.random()*types.length)];
        const e = { x:rx+0.5, y:ry+0.5, type:t, state:'idle', hearTarget:null, speed: (t==='sprinter'?3.6: (t==='patrol'?2.4:1.8)), patrolPath:[], patrolIndex:0, path:null, pathIndex:0, spotTimer:0 };
        if(t === 'patrol'){
          const ast = new AStar(world.map);
          const px = Math.floor(e.x), py = Math.floor(e.y);
          const tx = clamp(px + Math.floor(rand(-5,5)), 1, world.cols-2);
          const ty = clamp(py + Math.floor(rand(-5,5)), 1, world.rows-2);
          const path = ast.findPath(px,py,tx,ty);
          if(path && path.length>1) e.patrolPath = path;
        }
        enemies.push(e);
        placed++;
      }
    }
  }
}

/* ===== INPUT ===== */
const keys = {};
window.addEventListener('keydown', e=>{ keys[e.key] = true; if(e.key===' ') e.preventDefault(); if(e.key==='e' || e.key==='E'){ toggleEditor(); } });
window.addEventListener('keyup', e=>{ keys[e.key] = false; });

let mouse = { down:false };
canvas.addEventListener('mousemove', e=>{
  const mv = e.movementX || 0;
  if(player) player.dir += mv * 0.0025;
});
canvas.addEventListener('mousedown', e=>{ mouse.down = true; throwStone(e.clientX, e.clientY); });
canvas.addEventListener('mouseup', e=>{ mouse.down = false; });

/* ===== THROW STONE ===== */
let stones = [];
function throwStone(screenX, screenY){
  if(!running) return;
  const rect = canvas.getBoundingClientRect();
  const sx = screenX - rect.left;
  const cameraX = 2*sx / W - 1;
  const rayAng = player.dir + cameraX * (CONFIG.FOV/2);
  let px = player.x, py = player.y;
  const step = 0.2;
  for(let i=0;i<120;i++){
    px += Math.cos(rayAng) * step;
    py += Math.sin(rayAng) * step;
    const mx = Math.floor(px), my = Math.floor(py);
    if(my<0 || my>=world.rows || mx<0 || mx>=world.cols) break;
    if(world.map[my][mx] === 0){
      px -= Math.cos(rayAng) * step;
      py -= Math.sin(rayAng) * step;
      break;
    }
  }
  stones.push({ x: px, y: py, life: 6, noise: 6.0 });
  playSample('stone');
  for(const e of enemies){ e.hearTarget = { x:px, y:py, strength:6.0, time:performance.now() }; if(e.state !== 'chase') e.state = 'investigate'; }
}

/* ===== ENEMY UPDATE (A* etc) ===== */
function updateEnemies(dt){
  const ast = new AStar(world.map);
  for(const e of enemies){
    // hearing
    if(e.hearTarget){
      const ht = e.hearTarget;
      const d = Math.hypot(e.x - ht.x, e.y - ht.y);
      if(d < 0.6){
        e.state = 'search'; e.searchTimer = 2.0; e.hearTarget = null;
      } else {
        const path = ast.findPath(Math.floor(e.x), Math.floor(e.y), Math.floor(ht.x), Math.floor(ht.y));
        if(path){ e.path = path; e.pathIndex = 0; e.state = 'followPath'; }
        else {
          const ang = Math.atan2(ht.y - e.y, ht.x - e.x);
          e.x += Math.cos(ang) * e.speed * dt * 0.6;
          e.y += Math.sin(ang) * e.speed * dt * 0.6;
        }
        continue;
      }
    }

    // vision
    const canSee = (Math.hypot(e.x - player.x, e.y - player.y) < 6.5) && lineOfSight(e.x,e.y,player.x,player.y);
    if(canSee){
      e.state = 'chase'; playSample('alert'); e.lastSeen = {x:player.x, y:player.y, t: performance.now()};
    }

    if(e.state === 'chase'){
      const speedMultiplier = (e.type === 'sprinter') ? 1.7 : 1.15;
      const ang = Math.atan2(player.y - e.y, player.x - e.x);
      e.x += Math.cos(ang) * e.speed * dt * speedMultiplier;
      e.y += Math.sin(ang) * e.speed * dt * speedMultiplier;
      if(Math.hypot(e.x - player.x, e.y - player.y) < 0.45) gameOver();
      if(e.lastSeen && performance.now() - e.lastSeen.t > 2800){ e.state = 'search'; e.searchTimer = 3.0; }
      continue;
    } else if(e.state === 'followPath' && e.path){
      const tile = e.path[e.pathIndex];
      const tx = tile[0] + 0.5, ty = tile[1] + 0.5;
      const ang = Math.atan2(ty - e.y, tx - e.x);
      e.x += Math.cos(ang) * e.speed * dt;
      e.y += Math.sin(ang) * e.speed * dt;
      if(Math.hypot(e.x - tx, e.y - ty) < 0.25){
        e.pathIndex++;
        if(e.pathIndex >= e.path.length){ e.path = null; e.state = 'idle'; }
      }
    } else if(e.state === 'search'){
      e.searchTimer -= dt;
      const ang = rand(0, Math.PI*2);
      e.x += Math.cos(ang) * e.speed * dt * 0.6;
      e.y += Math.sin(ang) * e.speed * dt * 0.6;
      if(e.searchTimer <= 0) e.state = 'idle';
    } else if(e.type === 'stationary'){
      // guard: slight wiggle
      if(Math.random() < 0.01) e.spotTimer = rand(0,2);
    } else if(e.type === 'patrol' && e.patrolPath && e.patrolPath.length > 0){
      const tile = e.patrolPath[e.patrolIndex||0];
      const tx = tile[0] + 0.5, ty = tile[1] + 0.5;
      const ang = Math.atan2(ty - e.y, tx - e.x);
      e.x += Math.cos(ang) * e.speed * dt;
      e.y += Math.sin(ang) * e.speed * dt;
      if(Math.hypot(e.x - tx, e.y - ty) < 0.25){ e.patrolIndex = (e.patrolIndex+1) % e.patrolPath.length; }
    } else { // idle wander
      if(Math.random() < 0.008){
        const ang = rand(0, Math.PI*2);
        e.x += Math.cos(ang) * e.speed * dt * 0.4;
        e.y += Math.sin(ang) * e.speed * dt * 0.4;
      }
    }

    // keep inside floor
    if(world.map[Math.floor(e.y)] && world.map[Math.floor(e.y)][Math.floor(e.x)] === 0){
      e.x = clamp(e.x, 1.2, world.cols - 1.2);
      e.y = clamp(e.y, 1.2, world.rows - 1.2);
    }
  }
}

/* ===== COLLISION & LOS ===== */
function lineOfSight(ax,ay,bx,by){
  const dx = bx - ax, dy = by - ay;
  const steps = Math.ceil(Math.max(Math.abs(dx), Math.abs(dy)) * 6);
  for(let i=0;i<=steps;i++){
    const t = i/steps;
    const x = ax + dx*t, y = ay + dy*t;
    const mx = Math.floor(x), my = Math.floor(y);
    if(my<0 || my>=world.rows || mx<0 || mx>=world.cols) return false;
    if(world.map[my][mx] === 0) return false;
  }
  return true;
}

/* ===== PLAYER UPDATE ===== */
let stepTimer = 0;
function updatePlayer(dt){
  let mx=0,my=0;
  if(keys.w || keys.ArrowUp) my -= 1;
  if(keys.s || keys.ArrowDown) my += 1;
  if(keys.a || keys.ArrowLeft) mx -= 1;
  if(keys.d || keys.ArrowRight) mx += 1;
  player.sneaking = !!keys.Shift;
  const move = Math.hypot(mx,my);
  if(move>0){
    const nx = mx / move, ny = my / move;
    const forward = Math.cos(player.dir)*ny + Math.sin(player.dir)*nx;
    const side = -Math.sin(player.dir)*ny + Math.cos(player.dir)*nx;
    const spd = player.speed * (player.sneaking ? 0.75 : 1);
    player.x += (Math.cos(player.dir)*forward - Math.sin(player.dir)*side) * spd * dt;
    player.y += (Math.sin(player.dir)*forward + Math.cos(player.dir)*side) * spd * dt;
    // collision
    const mxcell = Math.floor(player.x), mycell = Math.floor(player.y);
    if(world.map[mycell] && world.map[mycell][mxcell] === 0){
      player.x -= (Math.cos(player.dir)*forward - Math.sin(player.dir)*side) * spd * dt;
      player.y -= (Math.sin(player.dir)*forward + Math.cos(player.dir)*side) * spd * dt;
    }
    player.noise = player.sneaking ? 0.4 : 1.0;
    stepTimer += dt;
    if(!player.sneaking && stepTimer > CONFIG.STEP_SOUND_INTERVAL){
      playSample('step');
      alertEnemiesByNoise();
      stepTimer = 0;
    }
  } else player.noise = 0;

  // exit check
  if(Math.hypot(player.x - world.exitPos.x, player.y - world.exitPos.y) < 0.6) winGame();
}

/* notify enemies by noise */
function alertEnemiesByNoise(){
  const px = player.x, py = player.y;
  for(const e of enemies){
    const d = Math.hypot(e.x - px, e.y - py);
    const aud = clamp(1 - (d/8), 0, 1) * player.noise * 4;
    if(aud > 0.12){
      e.hearTarget = { x:px, y:py, strength:aud, time:performance.now() };
      if(e.state !== 'chase') e.state = 'investigate';
    }
  }
}

/* ===== STONES UPDATE ===== */
function updateStones(dt){
  for(let i=stones.length-1;i>=0;i--){
    stones[i].life -= dt;
    if(stones[i].life <= 0) stones.splice(i,1);
  }
}

/* ===== GAME STATE ===== */
let running = false;
let startTime = 0;
let bestTime = localStorage.getItem('mindmaze_pro_best') || null;
if(bestTime) bestEl.textContent = String(Math.round(Number(bestTime)));
else bestEl.textContent = '--';

function startGame(){
  initWorld(); initPlayer(); spawnEnemies();
  startTime = performance.now(); running = true; menu.style.display = 'none';
  statusEl.textContent = 'Playing';
  if(actx.state === 'suspended') actx.resume();
  if(audioBuffers.bg){ if(bgSource) try{ bgSource.stop(); }catch(e){}; bgSource = playBuffer(audioBuffers.bg, 0.35, true); }
}

function gameOver(){
  if(!running) return;
  running = false;
  statusEl.textContent = 'Game Over';
  menu.style.display = 'flex';
  const dur = Math.round((performance.now() - startTime) / 1000);
  msg('Du wurdest erwischt — Zeit: ' + dur + 's');
}

function winGame(){
  if(!running) return;
  running = false;
  statusEl.textContent = 'Gewonnen';
  menu.style.display = 'flex';
  const dur = Math.round((performance.now() - startTime) / 1000);
  msg('Ausgang erreicht — Zeit: ' + dur + 's');
  if(!bestTime || dur > Number(bestTime)){ bestTime = dur; localStorage.setItem('mindmaze_pro_best', String(dur)); bestEl.textContent = String(dur); }
}

/* ===== RENDERER (textured walls + lighting approx) ===== */
function draw(){
  ctx.clearRect(0,0,W,H);
  // sky
  const grad = ctx.createLinearGradient(0,0,0,H*0.55); grad.addColorStop(0,'#14202a'); grad.addColorStop(1,'#050612'); ctx.fillStyle = grad; ctx.fillRect(0,0,W,H);
  // floor
  ctx.fillStyle = '#0b1014'; ctx.fillRect(0,H*0.62,W,H*0.38);

  // vertical slices
  for(let x=0;x<W;x++){
    const cameraX = 2*x / W - 1;
    const rayAng = player.dir + cameraX * (CONFIG.FOV/2);
    // raymarch
    let rx = player.x, ry = player.y, depth = 0, hit=false, hitX=0, hitY=0;
    const step = 0.02;
    while(!hit && depth < CONFIG.RENDER_DIST){
      rx += Math.cos(rayAng) * step;
      ry += Math.sin(rayAng) * step;
      const mx = Math.floor(rx), my = Math.floor(ry);
      if(my<0 || my>=world.rows || mx<0 || mx>=world.cols){ hit=true; break; }
      if(world.map[my][mx] === 0){ hit=true; hitX = mx; hitY = my; break; }
      depth += step;
    }
    const perpDist = Math.max(0.001, depth);
    const lineH = (CONFIG.CELL_SIZE * H) / (perpDist * CONFIG.CELL_SIZE) * 50;
    const drawStart = Math.floor(H*0.5 - lineH/2);
    const drawEnd = Math.floor(H*0.5 + lineH/2);

    // lighting & texture tint
    let light = clamp(1 - perpDist / CONFIG.RENDER_DIST, 0.12, 1);
    if(hit){
      light *= 0.9 + 0.12 * Math.abs(Math.sin(perpDist * 3));
    }
    const tintR = Math.floor(100 * light), tintG = Math.floor(140 * light), tintB = Math.floor(170 * light);

    // base column
    ctx.fillStyle = `rgb(${tintR},${tintG},${tintB})`;
    ctx.fillRect(x, drawStart, 1, Math.max(1, drawEnd - drawStart));

    // add faux texture: faint vertical stripes
    if((hitX + hitY) % 2 === 0){
      ctx.globalAlpha = 0.06; ctx.fillStyle = 'black'; ctx.fillRect(x, drawStart, 1, Math.max(1, drawEnd - drawStart)); ctx.globalAlpha = 1;
    }
    if(x % 7 === 0){
      ctx.globalAlpha = 0.02; ctx.fillStyle = 'white'; ctx.fillRect(x, drawStart, 1, Math.max(1, drawEnd - drawStart)); ctx.globalAlpha = 1;
    }
  }

  // reticle
  ctx.strokeStyle = 'rgba(220,240,255,0.28)';
  ctx.beginPath();
  ctx.moveTo(W/2 - 8, H/2);
  ctx.lineTo(W/2 + 8, H/2);
  ctx.moveTo(W/2, H/2 - 8);
  ctx.lineTo(W/2, H/2 + 8);
  ctx.stroke();

  drawMinimap();
}

/* ===== MINIMAP ===== */
function drawMinimap(){
  const mmW = minimapEl.clientWidth, mmH = minimapEl.clientHeight;
  if(!minimapEl._canvas){
    const c = document.createElement('canvas');
    c.width = mmW; c.height = mmH;
    c.style.width = '100%'; c.style.height = '100%';
    minimapEl.innerHTML = '';
    minimapEl.appendChild(c);
    minimapEl._canvas = c;
    minimapEl._ctx = c.getContext('2d');
  }
  const mc = minimapEl._canvas, mctx = minimapEl._ctx;
  mc.width = mmW * devicePixelRatio; mc.height = mmH * devicePixelRatio;
  mctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  mctx.clearRect(0,0,mmW,mmH);
  mctx.fillStyle = 'rgba(3,6,10,0.55)'; mctx.fillRect(0,0,mmW,mmH);
  const pad = 6; const mapW = world.cols, mapH = world.rows;
  const cellW = (mmW - pad*2) / mapW, cellH = (mmH - pad*2) / mapH;

  for(let y=0;y<mapH;y++){
    for(let x=0;x<mapW;x++){
      mctx.fillStyle = (world.map[y][x] === 0) ? '#223' : '#072';
      mctx.fillRect(pad + x*cellW, pad + y*cellH, cellW, cellH);
    }
  }
  // exit
  mctx.fillStyle = '#ffea80';
  mctx.fillRect(pad + (world.exit.x+0.25)*cellW, pad + (world.exit.y+0.25)*cellH, cellW*0.5, cellH*0.5);
  // stones
  for(const s of stones){
    mctx.fillStyle = '#bba';
    mctx.beginPath();
    mctx.arc(pad + s.x*cellW, pad + s.y*cellH, Math.max(1, Math.min(6, cellW*0.25)), 0, Math.PI*2);
    mctx.fill();
  }
  // enemies
  for(const e of enemies){
    mctx.fillStyle = (e.state === 'chase') ? '#ff6' : (e.type === 'stationary' ? '#aaf' : '#f66');
    mctx.beginPath();
    mctx.arc(pad + e.x*cellW, pad + e.y*cellH, Math.max(2, cellW*0.35), 0, Math.PI*2);
    mctx.fill();
    if(e.hearTarget){
      mctx.strokeStyle = 'rgba(255,255,255,0.18)';
      mctx.beginPath();
      mctx.arc(pad + e.hearTarget.x*cellW, pad + e.hearTarget.y*cellH, cellW*0.3, 0, Math.PI*2);
      mctx.stroke();
    }
  }
  // player
  mctx.fillStyle = '#8ef';
  mctx.beginPath();
  mctx.arc(pad + player.x*cellW, pad + player.y*cellH, Math.max(3, cellW*0.36), 0, Math.PI*2);
  mctx.fill();
  // dir
  mctx.strokeStyle = '#fff6';
  mctx.beginPath();
  mctx.moveTo(pad + player.x*cellW, pad + player.y*cellH);
  mctx.lineTo(pad + (player.x + Math.cos(player.dir)*0.8)*cellW, pad + (player.y + Math.sin(player.dir)*0.8)*cellH);
  mctx.stroke();
}

/* ===== GAME LOOP ===== */
let lastTime = 0;
function loop(ts){
  const dt = Math.min(0.033, (ts - lastTime) / 1000 || 0);
  lastTime = ts;
  if(running){
    updatePlayer(dt);
    updateEnemies(dt);
    updateStones(dt);
    // update stone lifetimes (already in updateStones)
  }
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ===== UI ===== */
startBtn.addEventListener('click', ()=> startGame());
editorBtn.addEventListener('click', ()=> { if(editor.active) { closeEditor(); } else openEditor(); });

function msg(text, dur=2500){
  statusEl.textContent = text;
  setTimeout(()=>{ statusEl.textContent = running ? 'Playing' : 'Ready'; }, dur);
}

/* ===== SOUND SAMPLES (fallback synth if no sample buffers) ===== */
function playSample(name){
  if(audioBuffers[name]){
    if(name === 'bg'){
      if(bgSource) try{ bgSource.stop(); }catch(e){}
      bgSource = playBuffer(audioBuffers[name], 0.35, true);
    } else playBuffer(audioBuffers[name], 0.9, false);
  } else {
    if(name === 'stone') synthBeep(1200,0.06,'triangle',0.06);
    else if(name === 'alert') synthBeep(320,0.12,'sawtooth',0.08);
    else if(name === 'step') synthBeep(880 + Math.random()*120, 0.03, 'sine', 0.03);
  }
}

/* ===== BOOT ===== */
function boot(){
  initWorld();
  initPlayer();
  spawnEnemies();
  draw();
}
boot();

/* Expose debug helpers in console */
window._mindmaze_pro = { regen: ()=>{ initWorld(); spawnEnemies(); draw(); }, world: ()=>world, player: ()=>player, enemies: ()=>enemies };

/* toggle editor by E */
function toggleEditor(){
  if(editor.active) closeEditor(); else openEditor();
}

/* minimal message on load */
msg('Bereit — drücken: Spiel starten oder E für Editor');

</script>
</body>
</html>
